OPTION EXPLICIT

HEADER

	DEFINE INITIAL												0
	DEFINE MAINTENANCE_UNACTUATED								1
	DEFINE MAINTENANCE_ACTUATED									2
	DEFINE MAINTENANCE_ACTUATING_FORWARD						3
	DEFINE MAINTENANCE_ACTUATING_BACKWARD						4
	DEFINE EXPERIMENT_UNACTUATED								5
	DEFINE EXPERIMENT_ACTUATING									6
	DEFINE MAINTENANCE_ACTUATED_TO_EXPERIMENT_UNACTUATED		7
	DEFINE MAINTENANCE_UNACTUATED_TO_EXPERIMENT_UNACTUATED		8
	DEFINE EXPERIMENT_UNACTUATED_TO_MAINTENANCE_UNACTUATED		9
	
	DEFINE PORT_IN 1
	DEFINE PIN_MODE_SWITCH			0
	DEFINE PIN_MODE_TRIGGER			1
	DEFINE PIN_PARA_INPUT			2
	
	DEFINE PORT_OUT 1
	DEFINE POUT_PARA_SWITCH				0
	DEFINE POUT_LAMP					1
	DEFINE POUT_RELAY					2
	DEFINE POUT_DISP_CLK_SHIFT			3
	DEFINE POUT_DISP_CLK_REFRESH		4
	DEFINE POUT_DISP_CLEAR_N			5
	DEFINE POUT_DISP_SERIAL1			6
	DEFINE POUT_DISP_SERIAL2			7
	
	DEFINE SWITCH_MAINTENANCE		1	
	DEFINE SWITCH_EXPERIMENT		0
	
	DEFINE RELAY_OFF			0
	DEFINE RELAY_ON				1
	
	DEFINE LAMP_OFF				0
	DEFINE LAMP_ON				1
	
	DEFINE TRIGGER_OFF			0
	DEFINE TRIGGER_ON			1
	
	DEFINE POSITION_MIN 0.0
	DEFINE POSITION_MAX 70.0
	
	DEFINE SPEED_SLOW 10.0
	DEFINE SPEED_FAST 30.0
	
	DEFINE DELAY_ACTUATING_FORWARD 2.5
	DEFINE DELAY_ACTUATING_BACKWARD 5.0
	DEFINE DELAY_LAMP 8.0
	DEFINE DELAY_CYCLE 0.005
	
	DEFINE PI 3.14159265359
	DEFINE NUM_OF_CMDS 10

END HEADER



DECLARATIONS
	GLOBAL state AS INTEGER = INITIAL
	GLOBAL state_next AS INTEGER = INITIAL
	
	GLOBAL trigger_curr AS INTEGER = 1
	GLOBAL trigger_prev AS INTEGER = 1
	
	GLOBAL error_count AS INTEGER = 0
	
	GLOBAL formatted_string AS STRING
	GLOBAL format_string AS STRING = "%d:\tPVT D %f , %f TIME %f\n"
END DECLARATIONS



PROGRAM

	ONTASKERROR error_handler
	SETJMP

	WHILE 1
		IF state == INITIAL THEN
			IF !(AXISSTATUS() & 0x01) THEN
				ENABLE
			END IF
			
			IF !(AXISSTATUS() & 0x02) THEN
				HOME
			END IF
			
			' TODO: Define relay behavior
			MOVEABS D POSITION_MIN F SPEED_FAST
			WAIT INPOS
			
			IF DIN(PORT_OUT, PIN_MODE_SWITCH) == SWITCH_MAINTENANCE THEN
				state_next = MAINTENANCE_UNACTUATED
			ELSE
				state_next = EXPERIMENT_UNACTUATED
			END IF
		
		ELSEIF state == MAINTENANCE_UNACTUATED THEN
			IF DIN(PORT_OUT, PIN_MODE_SWITCH) == SWITCH_EXPERIMENT THEN
				state_next = EXPERIMENT_UNACTUATED
			ELSE
				trigger_prev = trigger_curr
				trigger_curr = DIN(PORT_OUT, PIN_MODE_TRIGGER)
				
				IF trigger_prev == TRIGGER_OFF && trigger_curr == TRIGGER_ON THEN
					state_next = MAINTENANCE_ACTUATED
					
					' TODO: Define relay behavior
					MOVEABS D POSITION_MAX F SPEED_SLOW
					WAIT INPOS
				END IF
			END IF
				
		ELSEIF state == MAINTENANCE_ACTUATED THEN
			IF DIN(PORT_OUT, PIN_MODE_SWITCH) == SWITCH_EXPERIMENT THEN
				state_next = EXPERIMENT_UNACTUATED
				
				' TODO: Define relay behavior
				MOVEABS D POSITION_MIN F SPEED_SLOW
				WAIT INPOS
			ELSE
				trigger_prev = trigger_curr
				trigger_curr = DIN(PORT_OUT, PIN_MODE_TRIGGER)
				
				IF trigger_prev == TRIGGER_OFF && trigger_curr == TRIGGER_ON THEN
					state_next = MAINTENANCE_UNACTUATED
					
					' TODO: Define relay behavior
					MOVEABS D POSITION_MIN F SPEED_SLOW
					WAIT INPOS
				END IF
			END IF
			
		ELSEIF state == EXPERIMENT_UNACTUATED THEN
			IF DIN(PORT_OUT, PIN_MODE_SWITCH) == SWITCH_MAINTENANCE THEN
				state_next = MAINTENANCE_UNACTUATED
			ELSE
				trigger_prev = trigger_curr
				trigger_curr = DIN(PORT_OUT, PIN_MODE_TRIGGER)
				
				IF trigger_prev == TRIGGER_OFF && trigger_curr == TRIGGER_ON THEN
					' TODO: Define relay behavior
					' MOVEABS D POSITION_MAX F POSITION_MAX/DELAY_ACTUATING_FORWARD
					CALL pvt_wrapper(PFBKPROG(), POSITION_MAX, DELAY_ACTUATING_FORWARD)
					WAIT INPOS
					
					' TODO: Define relay behavior
					' MOVEABS D POSITION_MIN F POSITION_MAX/DELAY_ACTUATING_BACKWARD
					CALL pvt_wrapper(PFBKPROG(), POSITION_MIN, DELAY_ACTUATING_BACKWARD)
					WAIT INPOS
					
					DOUT PORT_OUT, POUT_LAMP:LAMP_ON
					DWELL DELAY_LAMP
					DOUT PORT_OUT, POUT_LAMP:LAMP_OFF
				END IF
			END IF
			
		ELSE
			state == INITIAL
		END IF
		
		DWELL DELAY_CYCLE
		state = state_next
	WEND
	
END PROGRAM



FUNCTION error_handler()
	state = INITIAL
	state_next = INITIAL
	
	error_count = error_count + 1
	
	IF AXISFAULT() != 0 THEN
        FAULTACK
    END IF

	LONGJMP	
END FUNCTION



FUNCTION get_x(BYVAL t AS DOUBLE, BYVAL xi AS DOUBLE, BYVAL xf AS DOUBLE, BYVAL tr AS DOUBLE) AS DOUBLE
	get_x = (xf-xi)/2*(-1*COS(t*PI/tr)+1) + xi
END FUNCTION

FUNCTION get_v(BYVAL t AS DOUBLE, BYVAL xi AS DOUBLE, BYVAL xf AS DOUBLE, BYVAL tr AS DOUBLE) AS DOUBLE
	get_v = (xf-xi)/2*((PI/tr)*SIN(t*PI/tr))
END FUNCTION

FUNCTION get_a(BYVAL t AS DOUBLE, BYVAL xi AS DOUBLE, BYVAL xf AS DOUBLE, BYVAL tr AS DOUBLE) AS DOUBLE
	get_a = (xf-xi)/2*((PI/tr)^2*COS(t*PI/tr))
END FUNCTION

FUNCTION compute_pvt(BYREF x_array(NUM_OF_CMDS) AS DOUBLE, BYREF v_array(NUM_OF_CMDS) AS DOUBLE, BYREF t_array(NUM_OF_CMDS) AS DOUBLE, BYVAL xi AS DOUBLE, BYVAL xf AS DOUBLE, BYVAL tf AS DOUBLE)
	DIM ii AS INTEGER
	FOR ii = 0 TO NUM_OF_CMDS-1
		t_array(ii) = ((ii+1)/NUM_OF_CMDS)*tf
		x_array(ii) = get_x(t_array(ii), xi, xf, tf)
		v_array(ii) = get_v(t_array(ii), xi, xf, tf)
	NEXT ii
END FUNCTION

FUNCTION execute_pvt(BYREF x_array(NUM_OF_CMDS) AS DOUBLE, BYREF v_array(NUM_OF_CMDS) AS DOUBLE, BYREF t_array(NUM_OF_CMDS) AS DOUBLE, BYVAL xi AS DOUBLE)
	DIM x_curr AS DOUBLE
	DIM ii AS INTEGER
	
	' PRINT "Loading PVT...\n"
	
	PVT INIT TIME ABS
	VELOCITY ON
	
	FOR ii = 0 TO NUM_OF_CMDS-1
		IF ii == 0 THEN
			x_curr = x_array(ii) - xi
		ELSE
			x_curr = x_array(ii) - x_array(ii-1)
		END IF
		
		IF ii == NUM_OF_CMDS-1 THEN
			VELOCITY OFF
		END IF
		
		PVT D x_curr, v_array(ii) TIME t_array(ii)
		
		' FORMAT formatted_string, format_string, INTV:ii, DBLV:x_curr, DBLV:v_array(ii), DBLV:t_array(ii)
		' PRINT formatted_string
		
	NEXT ii	
	
END FUNCTION

FUNCTION pvt_wrapper(BYVAL xi AS DOUBLE, BYVAL xf AS DOUBLE, BYVAL tf AS DOUBLE)
	DIM x_array(NUM_OF_CMDS) AS DOUBLE
	DIM v_array(NUM_OF_CMDS) AS DOUBLE
	DIM t_array(NUM_OF_CMDS) AS DOUBLE
	
	CALL compute_pvt(x_array, v_array, t_array, xi, xf, tf)
	CALL execute_pvt(x_array, v_array, t_array, xi)
END FUNCTION



FUNCTION rotate_left(BYVAL int_in AS INTEGER, BYVAL steps AS INTEGER) AS INTEGER
	DIM int_out AS INTEGER
	DIM temp0 AS INTEGER
	DIM temp1 AS INTEGER
	DIM ii AS INTEGER

	FOR ii = 0 TO steps-1
		temp0 = (int_in >> 31)
		temp1 = (int_in << 1)
		int_out = (temp0 | temp1)
	NEXT ii

	rotate_left = int_out
END FUNCTION

FUNCTION rotate_right(BYVAL int_in AS INTEGER, BYVAL steps AS INTEGER) AS INTEGER
	DIM int_out AS INTEGER
	DIM temp0 AS INTEGER
	DIM temp1 AS INTEGER
	DIM ii AS INTEGER

	FOR ii = 0 TO steps-1
		temp0 = (int_in << 31)
		temp1 = (int_in >> 1)
		int_out = (temp0 | temp1)
	NEXT ii

	rotate_right = int_out
END FUNCTION

FUNCTION reflect(BYVAL int_in AS INTEGER) AS INTEGER
    int_in = ((int_in >> 1) & 0x55555555u) | ((int_in & 0x55555555u) << 1)
    int_in = ((int_in >> 2) & 0x33333333u) | ((int_in & 0x33333333u) << 2)
    int_in = ((int_in >> 4) & 0x0f0f0f0fu) | ((int_in & 0x0f0f0f0fu) << 4)
    int_in = ((int_in >> 8) & 0x00ff00ffu) | ((int_in & 0x00ff00ffu) << 8)
    int_in = ((int_in >> 16) & 0xffffu) | ((int_in & 0xffffu) << 16)
    
	reflect = int_in
END FUNCTION